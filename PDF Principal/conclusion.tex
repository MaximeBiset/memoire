\newpage
\section{Conclusion}

Arrivé à la fin de ce projet,  il est temps de faire le bilan des contributions de ce mémoire.  Tout d'abord,  la première partie de ce travail a consisté en une bonne dose d'analyse.  En effet,  le domaine des économiqes locales de partage est assez varié et quelques exemples de projets existants ont été repris dans le chapitre dédié à l'explication du problème.  Cette diversité a permis de donner du sens à la réalisation d'un framework plutôt qu'un projet plus classique.  En effet,  le framework offre plus de possibilités de personnalisation qu'un logiciel paramétrable,  tel que Cyclos.  Cette première étape d'analyse apporte un résultat intéressant pour le futur : un modèle des features réutilisable pour tout projet lié à ce domaine.  En effet,  cette analyse peut tout à fait être réutilisée et adaptée en vue de servir à la rédaction d'un cahier des charges d'un projet informatique.  Les définitions des features peuvent amener une première description des fonctionnalités nécessaires et le dictionnaire des termes est également une bonne source d'introduction au domaine.   
Lors du développement proprement dit,  les deux outils utilisés peuvent être considérés comme indispensables pour mettre en place un projet de cette ampleur.  En effet,  pour développer un framework,  une première étape de rétro-ingénierie est nécessaire.  D'autant plus dans notre cas puisque nous avons développé un framework destiné au web,  et donc organisé en couches composées de classes et méthodes qui s'entre-mêlent.  Ainsi,  pouvoir utiliser le debugger à des endroits clés ainsi que le script de recherche de mots clés semble indispensable.  

D'un point de vue temporel du déroulement du projet,  on distingue clairement 2 étapes : la construction du feature model d'une part,  et le développement d'autre part.  Chacune d'elle fût divisée en étapes parfois communes.  En effet,  dans les 2 cas,  il a fallut commencer par intégrer des notions théoriques.  Pour l'analyse,  il s'agissait des modèles de features,  que je ne connaissais pas auparavant.  Pour le développement,  plusieurs éléments ont dû être assimilés.  D'abord,  après avoir choisit le projet issu du groupe d'étudiants,  il a fallu s'approprier le framework Django,  ainsi que Python,  langage déjà abordé dans le cadre de certains cours mais en guise d'outil et non comme objet d'étude.  Pour Django,  le tutoriel officiel fût bien utile mais s'est malheureusement avéré insuffisant.  En effet,  une fois que l'on plonge dans le code d'un projet tel que celui qui a servi de base,  on se rend compte de la richesse de cet outil et de la complexité que l'utilisation de cette dernière peut amener.  De plus,  certains éléments du projets ou de Django en général utilisent des notions avancées de Python.  Ces 2 éléments mis ensemble m'amènent à plusieurs conclusions.  D'abord,  le développement d'un framework est plus difficile que pour un logiciel plus classique.  Dès lors,  le choix du langage qui sera utilisé par les programmeurs doit être adapté à leurs compétences.  Dans le cadre de ce projet,  la question s'est posée au moment du choix entre Cyclos et la solution du groupe d'étudiants.  Je dois bien reconnaitre que je ne m'attendais pas à devoir faire face à ce niveau de maitrise du langage.  L'autre conclusion concerne le framework Django.   En effet,  en repensant aux problèmes rencontrés pendant le développement,  je me rends compte qu'une partie était liée au fonctionnement de Django.  Dès lors,  je fais le lien avec le choix pré-cité et je pense que c'est peut-être (il faudrait mener une étude comparative pour pouvoir l'affirmer) une mauvaise idée de se baser sur un logiciel utilisant lui-même un framework,  dans le but de créer un framework pour un domaine particulier.  Je pense cela car,  lors de ce projet,  j'ai souvent été confronté à me demander si une erreur était liée à une mauvaise utilisation du langage Python ou bien de Django.  Ceci complique beaucoup la programmation,  et le problème empire si,  comme c'est mon cas,  le programmeur n'est pas expert dans au moins une des deux technologies évoquées (dans mon cas,  j'avais quelques connaissances en Python et découvrait totalement Django).  La leçon à retenir se trouve donc dans les choix qui sont posés pour ce qui servira de base au développement du framework.  Si on désire réutiliser un projet existant basé lui-même sur un framework,  il vaut mieux s'entourrer d'une équipe de connaisseurs dans les technologies liées.  Notons aussi que j'ai souligné,  au début du travail,  que le développement d'un framework se fait généralement à partir d'une solution existante.  Peut-être que ce principe peut être remis en cause si on désire absolument travailler avec un framework applicatif (c'est-à-dire qui fourni un environnement technique) et dans ce cas,  démarer le framework ``from scratch'',  pour reprendre l'expression utilisée au début de ce mémoire.


En définitive,  nous avons vu dans le chapitre sur la validation que le framework n'est pas complet mais le reste du travail a donné des résultats intéressants dans divers domaines : l'analyse du  domaine des économies locales d'échange,  les outils pratiques pour le développement d'un framework ainsi que les bonnes pratiques de refactoring et enfin,  la conclusion que nous venons d'évoquer sur les choix faits avant de commencer la programmation.  